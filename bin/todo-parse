#!/usr/bin/perl
use strict;
use warnings;
use Term::ANSIColor;

my $file = "$ENV{HOME}/TODO";

my $usage = "Usage:
  $0 [-u|-r|-a|--qtodo]
    Parse ${file}'s git history to print todos
    -u       print unresolved, outstanding todos only
    -r       print resolved todos only
    -a       print all todos, unresolved first {default}
    --qtodo  print all todos as xml for qtodo

  $0 --add TODO [TODO TODO]   Add todos not in git history to $file
";

my %resColor = (
  FIXED => 'white bold',
  NONE => 'red bold',
  DISCARDED => 'blue bold',
);
my %resQtodoColor = (
  FIXED => 'green',
  NONE => 'red',
  DISCARDED => 'yellow',
);
my %resSym = (
  FIXED => 'x',
  NONE => ' ',
  DISCARDED => '~',
);

sub getTodos($$$$$);
sub todoFmt($$$$);
sub qtodoFmt($$$$$);
sub dateFmt($);
sub col($$);

sub main(@){
  my @todosToAdd = @_;
  my $fmtArg = '-a';
  if(@_ > 1 and $_[0] eq '--add'){
    shift;
    @todosToAdd = @_;
  }else{
    my $args = join "|", qw(-u -r -a --qtodo);
    die "Usage: $0 [$args]\n" if @_ > 1 or (@_ == 1 and $_[0] !~ /^$args$/);
    $fmtArg = shift;
  }

  my (%addTodos, %resolveTodos);

  my $diff = `git diff $file`;
  getTodos $diff, time(), '', \%addTodos, \%resolveTodos if length $diff > 0;

  for my $entry(`git log --format=format:"%H:::%at:::%s" $file`){
    if($entry =~ /^([a-f0-9]+):::(\d+):::(.*)$/){
      my ($commit, $date, $summary) = ($1, $2, $3);
      my $diff = `git diff-tree --cc $commit`;
      getTodos $diff, $date, $summary, \%addTodos, \%resolveTodos;
    }else{
      die "malformed git log line: $entry";
    }
  }

  for my $todo(keys %resolveTodos){
    die "todo never added: $todo\n" if not defined $addTodos{$todo};
  }

  my @todoPrefixLines;
  for my $todo(@todosToAdd){
    $todo = lc $todo;
    $todo =~ s/^\s*//;
    $todo =~ s/\s*$//;
    if(not defined $addTodos{$todo}){
      print STDERR "appending todo: '$todo'\n";
      push @todoPrefixLines, "-$todo\n";
      $addTodos{$todo} = [time(), undef];
    }
  }
  if(@todoPrefixLines > 0){
    open FH, "< $file" or die "Couldnt read $file\n";
    my @lines = <FH>;
    close FH;
    @lines = (@todoPrefixLines, @lines);
    open FH, "> $file" or die "Couldnt read $file\n";
    print FH @lines;
    close FH;
  }

  my @todos = sort {
    ${$addTodos{$b}}[0] <=> ${$addTodos{$a}}[0]
  } keys %addTodos;

  my $qtodoId = 0;
  my (@unresolvedQtodos, @resolvedQtodos);

  my (@unresolved, @resolved);

  for my $todo(@todos){
    my $dateAdded = dateFmt ${$addTodos{$todo}}[0];
    my $resTodo = $resolveTodos{$todo};
    my $resolution = defined $resTodo ? $$resTodo[1] : 'NONE';
    my $dateResolved = defined $resTodo ? dateFmt $$resTodo[0] : undef;

    if($fmtArg =~ /qtodo/){
      $qtodoId++;
      my $qtodo = qtodoFmt(
        $todo, $resolution, $dateAdded, $dateResolved, $qtodoId);
      if(defined $resTodo){
        push @resolvedQtodos, $qtodo;
      }else{
        push @unresolvedQtodos, $qtodo;
      }
    }else{
      my $line = todoFmt $todo, $resolution, $dateAdded, $dateResolved;
      if(defined $resTodo){
        push @resolved, $line;
      }else{
        push @unresolved, $line;
      }
    }
  }

  if($fmtArg =~ /qtodo/){
    print ''
      . "<?xml version='1.0' encoding='UTF-8'?>\n"
      . "<root max_id=\"$qtodoId\">\n"
      . join('', (@unresolvedQtodos, @resolvedQtodos))
      . "</root>\n"
  }else{
    print @unresolved if $fmtArg =~ /-a|-u/;
    print "\n\n\n" if $fmtArg =~ /-a/;
    print @resolved if $fmtArg =~ /-a|-r/;
  }
}

sub getTodos($$$$$){
  my ($diff, $date, $summary, $addTodos, $resolveTodos) = @_;
  my $resolution = $summary =~ /finish|complete|fix/i ? 'FIXED' : 'DISCARDED';

  if($diff =~ s/^
    (.*\n){2,5}
    ---.*\n
    \+\+\+.*\n
    @@.*@@\n//x){
    for my $line(split /\n/, $diff){
      if($line =~ /^\+-?(.*)$/){
        die "TODO ADDED TWICE: $line\n" if defined $$addTodos{$1};
        my $todo = lc $1;
        $$addTodos{$todo} = [$date, undef];
      }elsif($line =~ /^--?(.*)$/){
        die "TODO RESOLVED TWICE: $line\n" if defined $$resolveTodos{$1};
        my $todo = lc $1;
        $$resolveTodos{$todo} = [$date, $resolution];
      }
    }
  }else{
    die "malformed diff:\n$diff\n";
  }
}

sub todoFmt($$$$){
  my ($todo, $resolution, $dateAdded, $dateResolved) = @_;

  my $sym = $resSym{$resolution};
  my $color = $resColor{$resolution};

  return ''
    . "[$sym]"
    . " $dateAdded"
    . col($color, " $todo")
    . (defined $dateResolved ? " {$dateResolved}" : '')
    . "\n"
    ;
}

sub qtodoFmt($$$$$){
  my ($todo, $resolution, $dateAdded, $dateResolved, $id) = @_;

  $todo =~ s/&/\&amp;/g;
  $todo =~ s/</\&lt;/g;
  $todo = lc $todo;
  my $color = $resQtodoColor{$resolution};

  return ''
    . "  <to-do"
    . ($resolution eq 'NONE' ? '' : " done=\"true\"")
    . " id=\"$id\""
    . " color=\"$color\""
    . ">"
    . $todo
    . "</to-do>"
    . "\n"
    ;
}

sub dateFmt($){
  my $d = `date -d \@$_[0] +'%Y-%m-%d %H:%M'`;
  chomp $d;
  return $d;
}

sub col($$){
  return color($_[0]) . $_[1] . color('reset');
}

&main(@ARGV);
