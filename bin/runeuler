#!/usr/bin/perl
use strict;
use warnings;
use Getopt::Long qw(GetOptionsFromArray);

my $DIR = '/home/wolke/Euler';

my $usage = "Usage:
  $0 [-f|--force] [-q|--quiet] [-t N | --threads=N] PROBLEM
    PROBLEM must be an integer or 'all'
";

sub run($$$);
sub compile($$$$);

sub main(@){
  my $force;
  my $threads;
  my $quiet;

  my $ok = GetOptionsFromArray(\@_,
    'force', \$force,
    'quiet', \$quiet,
    'threads=i{1}', \$threads,
  );
  my $num = shift() || '';
  die $usage if not $ok or @_ > 0 or $num !~ /^(all|[0-9]+)$/;
  chdir $DIR;

  my @problemNumbers;
  if($num eq 'all'){
    my @problems = split /\n/, `ls -1 $DIR/problem*.hs`;

    my $max = 0;
    foreach my $prob(@problems){
      $prob =~ /([0-9]+)/;
      if($1 > $max){
        $max = $1;
      }
    }

    @problemNumbers = (1 .. $max);
  }else{
    @problemNumbers = ($num);
  }

  for my $num(@problemNumbers){
    if($num < 10){
      $num = "00$num";
    }elsif($num <100){
      $num = "0$num";
    }

    my $res = compile $num, $force, $quiet, $threads;
    if($res != 0){
      print "Compiled failed with code: $res\n";
    }else{
      run $num, $quiet, $threads;
    }
  }
}

sub compile($$$$){
  my $num = shift;
  my $force = shift;
  my $quiet = shift;
  my $threads = shift;

  if(defined $force){
    system "rm -f $DIR/problem$num";
    system "rm -f $DIR/problem$num.o";
    system "rm -f $DIR/problem$num.hi";
  }

  my $compile;
  if(defined $threads){
    $compile = "ghc --make -threaded $DIR/problem$num.hs -O";
  }else{
    $compile = "ghc --make $DIR/problem$num.hs -O";
  }

  if(defined $quiet){
    system "$compile -v0";
  }else{
    system "$compile";
  }

  return $?;
}

sub run($$$){
  my $num = shift;
  my $quiet = shift;
  my $threads = shift;
  
  if(not defined $quiet){
    print "Started running at " . localtime() . "\n";
  }

  my $exec;
  if(defined $threads){
    $exec = "$DIR/problem$num +RTS -N$threads -RTS";
  }else{
    $exec = "$DIR/problem$num";
  }  

  if(defined $quiet){
    my $start = time;
    
    my $out = `$exec`;
    chomp $out;
    $out =~ s/(?<=[^\\])\\n/\n/g;
    
    my $end = time;
    my $time = $end-$start;
  
    if($time < 10){
      $time = "00$time";
    }elsif($time <100){
      $time = "0$time";
    }

    print "p$num|$time|$out|\n";
  }else{
    my $out = `time $exec`;
    $out =~ s/(?<=[^\\])\\n/\n/g;
    print $out;
  }
}

&main(@ARGV);
