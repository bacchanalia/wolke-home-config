#!/usr/bin/perl
use strict;
use warnings;

my $totalLen = 34;
my $sepOffset = 3;

my $KLOMPDB = `echo -n \$HOME/.klompdb`;
my $KLOMPCUR = `echo -n \$HOME/.klompcur`;
my $KLOMPLAYER_PID = '/tmp/klomplayer_pid';

my $klompCmdExec = 'klomp-cmd';
my $klompTermExec = 'klomp-term';


my $LAUNCHERS = `echo -n \$HOME/.dzen2/launchers`;
my $PRINTERS = `echo -n \$HOME/.dzen2/printers`;

my $leftClickCmd = "xdotool key --clearmodifiers alt+9; " .
                   "$klompTermExec; ";
my $middleClickCmd = "$klompCmdExec reset";
my $rightClickCmd = "$klompCmdExec stop";

sub twoTextRows($$);
sub adjustLen($$$);

sub printer(@){
  my @args = @_;
  for my $arg(@args){
    $arg =~ s/\'/'\\''/g;
    $arg = "'$arg'";
  }
  my $out = `$PRINTERS/@args`;
  chomp $out;
  return $out;
}

sub wrapTokens(@){
  my @tokens;
  for my $token(@_){
    my $t = $token;
    $t =~ s/'/'\\''/g;
    push @tokens, "'$t'";
  }
  return @tokens;
}
sub shellQuiet(@){
  my $cmd = join ' ', wrapTokens(@_);
  return `$cmd 2>/dev/null`;
}

sub hms($){
  my $sex = shift;
  my $h = int($sex / (60*60));
  my $m = int($sex / (60));
  my $s = int($sex % (60));
  return ($h, $m, $s);
}
sub parseTime($$){
  my $pos = shift;
  my $len = shift;
  my ($pH, $pM, $pS) = hms $pos;
  my ($lH, $lM, $lS) = hms $len;
  my ($newPos, $newLen) = ('', '');
  if($pH > 0 or $lH > 0){
    my $hlen = length $pH;
    $hlen = length $lH if length $lH > $hlen;
    $newPos .= '0' x ($hlen - length $pH) . $pH . ':';
    $newLen .= '0' x ($hlen - length $lH) . $lH . ':';
  }
  $newPos .= '0' x (2 - length $pM) . $pM . ':';
  $newLen .= '0' x (2 - length $lM) . $lM . ':';

  $newPos .= '0' x (2 - length $pS) . $pS;
  $newLen .= '0' x (2 - length $lS) . $lS;

  return ($newPos, $newLen);
}
sub main(){
  my ($top, $bot);
  my $cur = -e $KLOMPCUR ? `cat $KLOMPCUR` : '';
  if($cur =~ /^([0-9\-\.]+) ([0-9\-\.]+) (.*)/){
    my $pos = $1;
    my $length = $2;
    ($pos, $length) = parseTime $pos, $length;
    my $path = $3;

    my @lines = split /\n/, $cur;

    my $artist = $lines[0];
    my $title = $lines[1];
    for my $line(@lines){
      if($line =~ /^artist(?:_guess)?=(.*)/){
        $artist = $1 if ($1 ne '');
      }elsif($line =~ /^title(?:_guess)?=(.*)/){
        $title = $1 if ($1 ne '');
      }
    }
    
    $top = "$pos-$artist";
    $bot = "$length-$title";

  }else{
    $top = "              KLOMP";
    $bot = "          no current song";
  }

  system "kill -0 `cat $KLOMPLAYER_PID`";
  if($? != 0){
    $top =~ s/^ //;
    $bot =~ s/^ //;
    $top = "x$top";
    $bot = "x$bot";
  }

  $top = adjustLen $top, $totalLen, $sepOffset;
  $bot = adjustLen $bot, $totalLen, $sepOffset;
  $top =~ s/\^/^^/g;
  $bot =~ s/\^/^^/g;
  my $markup = printer 'two-text-rows', $top, $bot, 36;
  $markup = printer 'click-action', 1, $leftClickCmd, $markup;
  $markup = printer 'click-action', 2, $middleClickCmd, $markup;
  $markup = printer 'click-action', 3, $rightClickCmd, $markup;
  print "$markup\n";
}

#replaces the middle of long strings with '...'
sub adjustLen($$$){
  my $str = shift;
  my $len = shift;
  my $offset = shift;
  my $sep = '...';
  my $strLen = length $str;
  if($strLen > $len){
    my $sepLen = length $sep;
    my $preSplit = ($len/2+$offset) - ($sepLen/2);
    my $postSplit = $strLen - ($len - $preSplit - $sepLen);
    $str = 
      (substr $str, 0, $preSplit) .
      $sep .
      (substr $str, $postSplit, $strLen-$postSplit+1);
    $strLen = length $str;
  }
  $str .= ' ' x ($len - $strLen);
  return $str;
}

main;

