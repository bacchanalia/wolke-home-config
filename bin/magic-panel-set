#!/usr/bin/perl
use strict;
use warnings;
use Safe;

my $gconftool = 'gconftool';

#global state
my %ids;

my $configFile = `echo -n ~/.gnome-panel/config.pl`;
print "Obtaining perl code from $configFile for safe evaluation\n";
open FH, "< $configFile";
my $unsafeCode = join '', <FH>;
close FH;

print "Safely evaluating the code slurped from $configFile\n";
my $compartment = new Safe;
my @panels = $compartment->reval($unsafeCode);
my $panelCount = @panels;
print "Loaded $panelCount panels from $configFile\n\n";

sub main(){
  my $backupFile = `echo -n ~/.gnome-panel/backup_`.time.'.xml';
  print "backing up /apps/panel to $backupFile\n";
  print " to restore, run: \n";
  print " '$gconftool --load $backupFile' \n";
  print " and then restart gnome-panel\n";
  system "$gconftool --dump /apps/panel > $backupFile";

  print "deleting all gnome panel settings\n";
  deleteRec('/apps/panel');

  for my $panel(@panels){
    print "adding panel, takes longer for more stuff...\n";
    parsePanel($$panel{props}, $$panel{items});
  }

  print "updating id lists\n";
  updateIDLists();

#  print "(re?)starting gnome-panel\n";
#  system 'gnome-panel --replace &';
#  exit 0;
}

###########################################################################
#PANEL CONFIG
#the subs above return a list representing a panel
#each element in the panel-list is a list representing one item, or 'SPLIT'
#  if one of the elements is the string 'SPLIT' instead of a list,
#  all elements that follow are spaced from the right towards the center
#the item-lists have 2-6 elements 
# [0] type  :: /apps/panel/[panels|objects]/$ID/object-type:
#             'menu-button'   => menu-object
#             'menu-bar'      => menu-bar
#             'drawer'        => drawer-object
#             'launcher'      => launcher-object
#             'menu-launcher' => launcher-object {existing .desktop file}
#             'applet'        => bonobo-applet
#             'action'        => action-applet
#             'separator'     => separator {missing from schema docs}
# [1] width :: how much space to leave for this element
#             dont overlap elements, behaviour is undefined
#for bonobo-applet:
# [2] server name :: the bonobo applet GNOME_*.server OAFIID
# [3] OPTIONAL applet schema name :: where the 'prefs' schemas live
#     e.g. 'cpufreq-applet' for /schema/apps/cpufreq-applet/prefs/cpu
# [4] OPTIONAL preferences :: hash of gconf key-names for prefs
#     e.g. 'show_mode'=>0 for /apps/panel/applets/cpu0/prefs/show_mode
#for launcher:
# [2] launcher name :: overwrites the LAUNCHER-NAME.desktop
# [3] command :: pasted as-is into the .desktop
# [4] icon :: pasted as-is into the .desktop
# [5] OPTIONAL terminal :: if true, app is launched in a terminal
#for menu-button:
# [2] OPTIONAL menu path, e.g.: applications://  {'' for none}
# [3] OPTIONAL custom icon
#for menu-bar: {NONE}
#for drawer: {NONE} and you will be sweared at
###########################################################################


#######################
### GCONF SHORTHAND ###
#######################
sub dirExists($){
  my $dir = shift;
  system $gconftool, '--dir-exists', $dir;
  return 0==$?;
}
sub getAll($){
  my $key = shift;
  my @all = `$gconftool --all-entries $key`;
  return @all;
}
sub getAllDirs($){
  my $key = shift;
  my @all = `$gconftool --all-dirs $key`;
  return @all;
}
sub deleteRec($){
  my $key = shift;
  system $gconftool, '--recursive-unset', $key;
}
sub lsGconf($){
  my $keydir = shift;
  my @children;
  my @lines = `$gconftool '--recursive-list' $keydir`;
  for my $line(@lines){
    if($line =~ /^ $keydir\/([^\/]*):/){
      push @children, $1;
    }
  }
  return @children;
}
sub applySchema($$){
  my $schema = shift;
  my $key = shift;
  system $gconftool, '--apply-schema', $schema, $key;
}
sub applySchemasRecursive($$);
sub applySchemasRecursive($$){
  my $schemaDir = shift;
  my $keyDir = shift;
  if(dirExists $schemaDir){
    for my $line(getAll $schemaDir){
      if($line =~ /^ ([a-zA-Z_-]+) = /){
        my $prop = $1;
        applySchema "$schemaDir/$prop", "$keyDir/$prop";
      }
    }
    for my $line(getAllDirs $schemaDir){
      if($line =~ /^ $schemaDir\/([a-zA-Z_-]+)/){
        my $propDir = $1;
        applySchemasRecursive("$schemaDir/$propDir", "$keyDir/$propDir");
      }
    }
  }
}

sub set($$$){
  my $type = shift;
  my $key = shift;
  my $value = shift;
  system $gconftool, '--type', $type, '--set', $key, $value;
}
sub setList($$\@){
  my $listType = shift;
  my $key = shift;
  my @values = @{shift()};

  for my $val(@values){
    $val =~ s/\\/\\\\/g;
    $val =~ s/,/\\,/g;
    $val =~ s/]/\\]/g;
  }
  my $value = '[' . join(',', @values) . ']';
  system $gconftool, '--type', 'list',
    '--list-type', $listType, '--set', $key, "$value";
}
sub getType($){
  my $val = shift;
  if($val =~ /^(true|false)$/){
    return 'bool';
  }elsif($val =~ /^\d+$/){
    return 'int';
  }elsif($val =~ /^-?\d*\.\d*$/){
    return 'float'
  }elsif($val =~ /^\[.*\]$/){
    return 'list';
  }elsif($val =~ /^"(.*)"$/){
    return 'string';
  }elsif(length $val == 0){
    return 'string';
  }else{
    return undef;
  }
}

sub setProps($$$\%){
  my $name = shift;
  my $prefix = shift;
  my $schemaPrefix = shift;
  my $props = shift;

  applySchemasRecursive("/schemas/$schemaPrefix", "/$prefix/$name");

  for my $prop(keys %$props){
    my $key = "/$prefix/$name/$prop";
    my $val = $$props{$prop};
    my $type = getType $val;
    if(not defined $type){
      die "wrap gconf string values in double-quotes please: $key=$val\n";
    }
    if($type eq 'string'){
      $val = $1 if $val =~ /^"(.*)"$/;
      set($type, $key, $val);
    }elsif($type eq 'list'){
      $val = $1 if $val =~ /^\[(.*)\]$/;
      my @vals = split ',', $val;

      my $listType;
      if(@vals > 0){
        $listType = getType $vals[0];
        if(not defined $listType){
          $listType = 'string';
        }
      }else{
        $listType = 'string';
      }
      setList($listType, $key, @vals);
    }else{
      set($type, $key, $val);
    }
  }
}



#####################
### PANEL OBJECTS ###
#####################
sub createLauncherDesktop($$$$){
  my $name = shift;
  my $exec = shift;
  my $icon = shift;
  my $term = shift;

  my $dir = `echo -n ~/.gnome2/panel2.d/default/launchers`;
  my $fileName = $name;
  $fileName =~ s/[ \t\n\/\\]/-/g;
  my $time = time;
  my $file = "$dir/$fileName-auto-$time.desktop";

  my $content =
"#!/usr/bin/env xdg-open

[Desktop Entry]
Version=1.0
Type=Application
Terminal=$term
Icon[en_US]=$icon
Name[en_US]=$name
Exec=$exec
Name=$name
Icon=$icon
";

  open FH, "> $file" or die "could not open $file for writing";
  print FH $content;
  close FH;

  return $file;
}
sub addAppletPrefs($$\%){
  my $id = shift;
  my $prefsSchemaDir = shift;
  my %prefs = %{shift()};
  
  #prepend keys with 'prefs/'
  %prefs = map {('prefs/'.$_) => $prefs{$_}} keys %prefs;

  setProps($id, 'apps/panel/applets', "apps/$prefsSchemaDir", %prefs);
}

sub addItem($$\%){
  my $id = shift;
  my $propDir = shift;
  my $props = shift;

  setProps $id, "apps/panel/$propDir", 'apps/panel/objects', %$props;
}

sub updateIDLists(){
  my @toplevels = lsGconf '/apps/panel/toplevels';
  my @applets = lsGconf '/apps/panel/applets';
  my @objects = lsGconf '/apps/panel/objects';
  setList 'string', '/apps/panel/general/toplevel_id_list', @toplevels;
  setList 'string', '/apps/panel/general/applet_id_list', @applets;
  setList 'string', '/apps/panel/general/object_id_list', @objects;
}

sub nextID($){
  my $base = shift;
  return $base . $ids{$base}++;
}

sub parsePanel(\%\@){
  my $props = shift;
  my @items = @{shift()};
  if(@items == 0){
    return;
  }

  my $baseID = 'panel';
  my $orientation = lc $$props{'orientation'};
  if($orientation =~ /^"([a-z]+)"$/){
    $baseID = $1 . '_' . $baseID;
  }
  my $panelID = nextID $baseID;
  
  setProps($panelID, 'apps/panel/toplevels', 'apps/panel/toplevels',
    %$props);

  my $curPos = 0;
  my $right = 'false';
  for my $item(@items){
    if($item =~ /SPACER_([0-9]+)/){
      $curPos += $1;
    }elsif($item eq 'SPLIT'){
      $right = 'true';
      $curPos = 0;
    }else{
      my @itemArr = @{$item};
      my $props = {
        toplevel_id          => '"'.$panelID.'"',
        position             => $curPos,
        panel_right_stick    => $right,
        locked               => 'true',
      };

      my $type = $itemArr[0];
      my $size = $itemArr[1];
      if($type eq 'applet'){
        my $appletServer = $itemArr[2];
        my $appletSchemaName = @itemArr > 3 ? $itemArr[3] : '';
        my $prefs = @itemArr > 4 ? $itemArr[4] : {};
        my $baseID;
        if($appletServer =~ /^GNOME_(.*)Applet$/){
          $baseID = lc $1;
        }else{
          $baseID = lc $appletServer;
        }
        my $itemID = nextID $baseID;

        $$props{object_type} = '"bonobo-applet"';
        $$props{bonobo_iid} = '"OAFIID:' . $appletServer . '"';
        addItem($itemID, 'applets', %$props);
        if(length $appletSchemaName > 0){
          addAppletPrefs($itemID, $appletSchemaName, %$prefs);
        }
      }elsif($type eq 'menu-bar'){
         my $itemID = nextID 'menubar';
         $$props{object_type} = '"menu-bar"';
         addItem($itemID, 'objects', %$props);
      }elsif($type eq 'menu-button'){
         my $itemID = nextID 'menu';
         my $loc = @itemArr > 2 ? $itemArr[2] : '';
         my $icon = @itemArr > 3 ? $itemArr[3] : '';
         $$props{object_type} = '"menu-object"';
         $$props{menu_path} = '"'.$loc.'"';
         $$props{use_menu_path} = length $loc > 0 ? 'true' : 'false';
         $$props{custom_icon} = '"'.$icon.'"';
         $$props{use_custom_icon} = length $icon > 0 ? 'true' : 'false';
         addItem($itemID, 'objects', %$props);
      }elsif($type eq 'drawer'){
         die "fuck you man, i dont DO drawers\n";
      }elsif($type eq 'separator'){
         $$props{object_type} = '"separator"';
         my $itemID = nextID 'sep';
         addItem($itemID, 'objects', %$props);
      }elsif($type eq 'action'){
         my $itemID = nextID 'action';
         my $action = $itemArr[2];
         $$props{object_type} = '"action-applet"';
         $$props{action_type} = '"'.$action.'"';
         addItem($itemID, 'objects', %$props);
      }elsif($type eq 'launcher'){
         my $name = $itemArr[2];
         my $itemName = $name;
         $itemName =~ s/[^a-zA-Z0-9_]+/_/g;
         my $itemID = nextID $itemName;
         my $exec = $itemArr[3];
         my $icon = $itemArr[4];
         my $term = @itemArr > 5 ? $itemArr[5] : 'false';
         my $file = createLauncherDesktop($name, $exec, $icon, $term);
         
         $$props{object_type} = '"launcher-object"';
         $$props{launcher_location} = '"'.$file.'"',
         addItem($itemID, 'objects', %$props);
      }elsif($type eq 'menu-launcher'){
         $$props{object_type} = '"launcher-object"';
         my $file = $itemArr[2];
         my $itemID;
         if($file =~ /(?:^|\/)  ([^\/]*)  \.desktop$/x){
           my $name = lc $1;
           $name =~ s/[^a-z0-9_-]//g;
           $itemID = nextID $name;
         }else{
           $itemID = nextID 'launcher';
         }
         $$props{object_type} = '"launcher-object"';
         $$props{launcher_location} = '"'.$file.'"',
         addItem($itemID, 'objects', %$props);
      }
      $curPos += $size;
    }
  }
}

&main;

