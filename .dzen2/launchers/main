#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(sleep time);
use IO::Handle;

my $height = 24;
for(my $i=0; $i<@ARGV; $i++){
  if($ARGV[$i] eq '-h'){
    $i++;
    if($i<@ARGV and $ARGV[$i] =~ /^\d+$/){
      $height = $ARGV[$i];
      last;
    }
  }
}
for(my $i=0; $i<@ARGV; $i++){
  if($ARGV[$i] eq '-x'){
    $ARGV[$i] = '';
    $ARGV[$i+1] = '';
  }
}
sub getIO($);

my $DIR = "\$HOME/.dzen2/printers";

sub debugPrint($){
  #print $_[0];
}

my $spacer = [once => "echo -n ' ^p(;-8)^fg(black)^r(3x$height)^fg()^p(;8) '"];
my $smallSpace = [once => "echo -n '^p(2)'"];

my $cpuCount = `cat /proc/cpuinfo | grep processor | wc -l`;
my @cpuScaling;
for(my $i=0; $i<$cpuCount; $i++){
  push @cpuScaling, [LOOP => "$DIR/cpu-scaling $i 0.5"];
  if($i < $cpuCount - 1){
    push @cpuScaling, $smallSpace;
  }
}


my @printerCommands = (
  $spacer,
  [once => "$DIR/fcrondyn"],
  [once => "$DIR/klomp"],
  [once => "$DIR/volume $height"],
  [once => "$DIR/mic"],
  $spacer,
  [once => "$DIR/pidgin-pipe-notification $height"],
  [once => "$DIR/tbunreadcounts"],
  $spacer,
  [once => "$DIR/cpu-scaling-gov-tiny"],
  $smallSpace,
  [LOOP => "sudo $DIR/i7z-cpu-freq"],
  $spacer,
  [LOOP => "$DIR/monitor-ping www.google.com G 5 -loop"],
  [once => "$DIR/openvpn"],
  [LOOP => "$DIR/monitor-ping source.escribe.com E 5 -loop"],
  $spacer,
  [LOOP => "/usr/lib/tpbattstat-applet/tpbattstat.py --dzen 2500"],
  $spacer,
  [once => "$DIR/clock"],
  $smallSpace,
);

my @monitorCommands = (
  $spacer,
  [LOOP => "$DIR/cpu-monitor 1.5 $height"],
  $smallSpace,
  [LOOP => "$DIR/mem-monitor 1.5 $height"],
);
sub loop($$$$);

sub main(){
  my $monitorWidth = 18+($height+3)*2;
  my $left = 870;
  if(fork()){
    loop $left, $monitorWidth, 500, \@monitorCommands;
  }else{
    loop $left+$monitorWidth, 0, 400, \@printerCommands;
  }
}

sub loop($$$$){
  my $x = shift;
  if($x == 0){
    $x = '';
  }else{
    $x = "-x $x";
  }
  my $w = shift;
  if($w == 0){
    $w = '';
  }else{
    $w = "-w $w";
  }

  my $interval_millis = shift;

  my @cmds = @{shift()};
  
  open DZEN, "| dzen2 $w $x @ARGV";

  my @previousOutputs = map {'---'} @printerCommands;
  my @printers;
  for my $cmdArr(@cmds){
    my $schedule = $$cmdArr[0];
    my $cmd = $$cmdArr[1];
    if(lc $schedule eq 'loop'){
      push @printers, ['iohandle', getUnblockedIO($cmd)];
    }elsif(lc $schedule eq 'once'){
      push @printers, ['command', $cmd];
    }
  }
  for my $p(@printers){
    debugPrint $$p[0] . " => " . $$p[1] . "\n";
  }

  while(1){
    my $start = time;
    debugPrint "\n\n\nStarting a round\n";
    print DZEN getOutput(\@printers, \@previousOutputs);
    print DZEN "\n";
    my $end = time;
    my $elapsed = $end - $start;
    my $toSleep = ($interval_millis / 1000.0) - $elapsed;
    debugPrint
      sprintf("Round took %.6fs, sleeping for %.6fs\n", $elapsed, $toSleep);
    if($toSleep > 0){
      sleep $toSleep;
    }
  }
}


sub getCommandOutput($$){
  my $command = shift;
  my $previousOutput = shift;
  my $out = `$command`;
  $out =~ s/\n*//g;
  if(not $out){
    return $previousOutput;
  }
  return $out;
}
sub getIOHandleOutput($$){
  my $io = shift;
  my $previousOutput = shift;
  my @lines = $io->getlines();
  if(@lines == 0){
    return $previousOutput;
  }
  my $out = $lines[-1];
  chomp $out;
  return $out;
}
sub getOutput($$){
  my $output = '';
  my $printers = shift;
  my $previousOutputs = shift;
  for(my $i=0; $i<@{$printers}; $i++){
    my $printer = $$printers[$i];
    my $out;
    my $start = time;
    if($$printer[0] eq 'command'){
      $out = getCommandOutput $$printer[1], $$previousOutputs[$i];
    }elsif($$printer[0] eq 'iohandle'){
      $out = getIOHandleOutput $$printer[1], $$previousOutputs[$i];
    }
    my $end = time;
    debugPrint
      sprintf("Command#%d took %.6fs (%s)\n", $i, ($end - $start), $$printer[1]);
    $$previousOutputs[$i] = $out;
    $output .= $out;
  }
  return $output;
}

#for some incomprehensible reason,
#if i dont keep a reference around to the file descriptor,
#its closed as soon as the scope ends
my @fileHandleReferences;
sub getUnblockedIO($){
  my $cmd = shift;
  my $io = IO::Handle->new();
  my $fh = undef;
  open $fh, "$cmd |";
  $io->fdopen($fh, 'r');
  $io->blocking(0);
  push @fileHandleReferences, $fh;
  return $io;
}

main;
