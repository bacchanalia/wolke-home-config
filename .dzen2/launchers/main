#!/usr/bin/perl
use strict;
use warnings;
use Time::HiRes qw(sleep time);
use IO::Handle;

my $height = 24;
for(my $i=0; $i<@ARGV; $i++){
  if($ARGV[$i] eq '-h'){
    $i++;
    if($i<@ARGV and $ARGV[$i] =~ /^\d+$/){
      $height = $ARGV[$i];
      last;
    }
  }
}

sub getIO($);

my $DIR = "\$HOME/.dzen2/printers";

my $INTERVAL_MS = 950;
my $spacer = [once => "echo -n ' ^p(;-8)^fg(black)^r(3x$height)^fg()^p(;8) '"];
my $smallSpace = [once => "echo -n '^p(2)'"];

my $cpuCount = `cat /proc/cpuinfo | grep processor | wc -l`;
my @cpuScaling;
for(my $i=0; $i<$cpuCount; $i++){
  push @cpuScaling, [LOOP => "$DIR/cpu-scaling $i 0.5"];
  if($i < $cpuCount - 1){
    push @cpuScaling, $smallSpace;
  }
}


my @printerCommands = (
  $spacer,
  [once => "$DIR/rbox"],
  $spacer,
  [once => "$DIR/tbunreadcounts"],
  $spacer,
  [LOOP => "$DIR/cpu-monitor 1.0 $height"],
  $smallSpace,
  [LOOP => "$DIR/mem-monitor 1.0 $height"],
  $spacer,
  @cpuScaling,
  $spacer,
  [once => "$DIR/mic"],
  [once => "$DIR/commandclick firefox"],
  $spacer,
  [LOOP => "$DIR/monitor-ping www.google.com g 5 -loop"],
  [once => "$DIR/openvpn"],
  [LOOP => "$DIR/monitor-ping source.escribe.com e 5 -loop"],
  $spacer,
  [LOOP => "/usr/lib/tpbattstat-applet/tpbattstat.py --dzen 2500"],
  $spacer,
  [once => "$DIR/clock"],
  $smallSpace,
);
my @previousOutputs = map {'---'} @printerCommands;

sub main(){
  open DZEN, "| dzen2 @ARGV";

  my @printers;
  for my $cmdArr(@printerCommands){
    my $schedule = $$cmdArr[0];
    my $cmd = $$cmdArr[1];
    if(lc $schedule eq 'loop'){
      push @printers, ['iohandle', getUnblockedIO($cmd)];
    }elsif(lc $schedule eq 'once'){
      push @printers, ['command', $cmd];
    }
  }
  for my $p(@printers){
    print $$p[0] . " => " . $$p[1] . "\n";
  }

  while(1){
    my $start = time;
    print "\n\n\nStarting a round\n";
    print DZEN getOutput(\@printers);
    print DZEN "\n";
    my $end = time;
    my $elapsed = $end - $start;
    my $toSleep = ($INTERVAL_MS / 1000.0) - $elapsed;
    printf "Round took %.6fs, sleeping for %.6fs\n", $elapsed, $toSleep;
    if($toSleep > 0){
      sleep $toSleep;
    }
  }
}


sub getCommandOutput($$){
  my $command = shift;
  my $previousOutput = shift;
  my $out = `$command`;
  $out =~ s/\n*//g;
  if(not $out){
    return $previousOutput;
  }
  return $out;
}
sub getIOHandleOutput($$){
  my $io = shift;
  my $previousOutput = shift;
  my @lines = $io->getlines();
  if(@lines == 0){
    return $previousOutput;
  }
  my $out = $lines[-1];
  chomp $out;
  return $out;
}
sub getOutput($){
  my $output = '';
  my $printers = shift;
  for(my $i=0; $i<@{$printers}; $i++){
    my $printer = $$printers[$i];
    my $out;
    my $start = time;
    if($$printer[0] eq 'command'){
      $out = getCommandOutput $$printer[1], $previousOutputs[$i];
    }elsif($$printer[0] eq 'iohandle'){
      $out = getIOHandleOutput $$printer[1], $previousOutputs[$i];
    }
    my $end = time;
    printf "Command#%d took %.6fs (%s)\n", $i, ($end - $start), $$printer[1];
    $previousOutputs[$i] = $out;
    $output .= $out;
  }
  return $output;
}

#for some incomprehensible reason,
#if i dont keep a reference around to the file descriptor,
#its closed as soon as the scope ends
my @fileHandleReferences;
sub getUnblockedIO($){
  my $cmd = shift;
  my $io = IO::Handle->new();
  my $fh = undef;
  open $fh, "$cmd |";
  $io->fdopen($fh, 'r');
  $io->blocking(0);
  push @fileHandleReferences, $fh;
  return $io;
}

main;
