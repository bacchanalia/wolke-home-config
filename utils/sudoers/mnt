#!/usr/bin/perl
use strict;
use warnings;

my $mountDir = '/media';

sub mount($);
sub unmount($);
sub blkid();
sub udevadm($);
sub getName($);
sub isUsb($);
sub run(@);
sub runFail(@);
sub runFailEcho(@);

my $usage = "Usage:
  $0          mount all usb partitions at /media/NAME
  $0 -m       mount all usb partitions at /media/NAME
  $0 -u       unmount all usb paritions at /media/NAME

  $0 -g       for all usb partitions, print 'NAME size {mounted} dev'
  $0 -n       for all usb partitions, print NAMEs
  
  $0 -l       loop every 1s, mounting all usb partitions at /media/NAME
  $0 -l NAME  loop every 1s, waiting for NAME, mount it and exit when found
  
  $0 -m NAME  mount NAME at /media/NAME
  $0 -u NAME  unmount /media/NAME
  
  NAME is either
    1) the partition label if blkid finds one
    2) <devname>  or  <devname>_<size>GiB
       if the device is /dev/<devname> and <devname> is alphanumeric
       <size> is the size in GiB, truncated to tenths, if udev reports it
    3) uuid otherwise
";

sub main(@){
  my $cmd = shift() || "-m";
  die $usage if $cmd !~ /^(-m|-u|-g|-n|-l)$/;
  my $name = shift if $cmd =~ /^(-m|-u|-l)$/;

  die $usage if @_ > 0;

  my @usbParts = grep {isUsb $_} blkid();
  my $selectedPart;
  if(defined $name){
    foreach(@usbParts){
      if(${$_}{name} eq $name){
        $selectedPart = $_;
        last;
      }
    }
    die "Unknown NAME $name; try '$0 -g'\n" if not defined $selectedPart;
  }

  if($cmd eq '-m'){
    if(defined $selectedPart){
      die "already mounted\n" if isMounted(${$selectedPart}{dev});
      mount $selectedPart;
    }else{
      my @unmounted = grep {!isMounted(${$_}{dev})} @usbParts;
      mount $_ foreach @unmounted;
    }
  }elsif($cmd eq '-u'){
    if(defined $selectedPart){
      die "already unmounted\n" if !isMounted(${$selectedPart}{dev});
      unmount $selectedPart;
    }else{
      my @mounted = grep {isMounted(${$_}{dev})} @usbParts;
      unmount $_ foreach @mounted;
    }
  }elsif($cmd eq '-g'){
    foreach(@usbParts){
      my %p = %{$_};
      my $name = "$p{name}";
      my $size = " $p{sizeGiB}GiB" if defined $p{sizeGiB};
      my $mounted = isMounted($p{dev}) ? ' mounted' : ' unmounted';
      my $dev = " $p{dev}";
      print "$name$size$mounted$dev\n";
    }
  }elsif($cmd eq '-n'){
    foreach(@usbParts){
      print "${$_}{name}\n";
    }
  }elsif($cmd eq '-l'){
    if(defined $name){
      while(1){
        print "waiting for $name\n";
        my %newNames = map {chomp $_; $_ => 1} `$0 -n`;
        last if defined $newNames{$name};
        sleep 1;
      }
      print "found! mounting $name\n";
      system $0, "-m", $name;
    }else{
      while(1){
        print "$0 -m\n";
        system $0, "-m";
        sleep 1;
      }
    }
  }
}

sub isMounted($){
  my $dev = shift;
  my $mountOut = `mount`;
  if($mountOut =~ /^$dev on /m){
    return 1;
  }else{
    return 0;
  }
}

sub isMountedOn($$){
  my ($dev, $mountPoint) = @_;
  my $mountOut = `mount`;
  if($mountOut =~ /^$dev on $mountPoint /m){
    return 1;
  }else{
    return 0;
  }
}

sub mount($){
  my %p = %{shift()};
  my $mountPoint = "$mountDir/$p{name}";
  die "$p{dev} already mounted\n" if isMountedOn $p{dev}, $mountPoint;
  
  run "rmdir $mountPoint 2>/dev/null";
  if(-e $mountPoint){
    die "$mountPoint exists and is not removable with rmdir";
  }
  runFail "mkdir", $mountPoint;
  
  runFailEcho "mount", "-t", $p{type}, $p{dev}, $mountPoint;
  if(isMountedOn $p{dev}, $mountPoint){
    print "  OK\n";
  }else{
    die "$p{dev} not mounted on $mountPoint, according to mtab";
  }
}

sub unmount($){
  my %p = %{shift()};
  my $mountPoint = "$mountDir/$p{name}";
  die "$p{dev} not mounted\n" if !isMountedOn $p{dev}, $mountPoint;
  runFailEcho "umount", $mountPoint;
  runFail "rmdir", $mountPoint;
  if(not -e $mountPoint){
    print "  OK\n";
  }else{
    die "$mountPoint still exists";
  }
}

sub blkid(){
  my @partitions;
  for my $line(`blkid`){
    my %p;
    $p{dev} = $1 if $line =~ /^(.*):/;
    $p{label} = $1 if $line =~ /LABEL="([^"]+)"/;
    $p{uuid} = $1 if $line =~ /UUID="([^"]+)"/;
    $p{type} = $1 if $line =~ /TYPE="([^"]+)"/;

    $p{udev} = udevadm $p{dev};

    my $size = $p{udev}{UDISKS_PARTITION_SIZE};
    if(defined $size and $size =~ /^\d+$/){
      $p{sizeGiB} = sprintf "%.1f", $size / 2**30;
    }
    
    $p{name} = getName \%p;
     
    push @partitions, \%p;
  }
  return @partitions;
}

sub udevadm($){
  my $dev = shift;
  my %udev;
  for my $line(`udevadm info --query=property --name=$dev`){
    if($line =~ /^([a-z0-9_\-]+)=(.*)$/i){
      $udev{$1} = $2;
    }
  }
  return \%udev;
}

sub getName($){
  my %p = %{shift()};

  if(defined $p{label} and length $p{label} > 0){
    return $p{label};
  }

  my $dev = $p{dev};
  $dev = '' if not defined $dev;
  if($dev =~ /^\/dev\/([a-z0-9]+)$/i){
    my $devName = $1;
    if(defined $p{sizeGiB}){
      return "${devName}_$p{sizeGiB}GiB";
    }else{
      return $devName;
    }
  }

  return $p{uuid};
}

sub isUsb($){
  my %p = %{shift()};
  my $idPath = ${$p{udev}}{ID_PATH};
  if(defined $idPath and $idPath =~ /-usb-/){
    return 1;
  }else{
    return 0;
  }
}

sub run(@){
  system @_;
}
sub runFail(@){
  run @_;
  die "Command failed: @_\n" if $? != 0;
}
sub runFailEcho(@){
  print "@_\n";
  runFail @_;
}

&main(@ARGV);
